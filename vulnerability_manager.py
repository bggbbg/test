import docker
import os
import requests
from rich.console import Console
from typing import Dict, Any
import json
import time

console = Console()

class VulnerabilityManager:
    def __init__(self):
        self.client = docker.from_env()
        self.environments = {}
        self.cve_api_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        
    def setup_environment(self, cve_id: str) -> Dict[str, Any]:
        """
        根据CVE编号搭建漏洞环境
        """
        try:
            # 检查是否已有该CVE的环境配置
            if cve_id in self.environments:
                return self.environments[cve_id]
                
            # 从CVE数据库获取漏洞信息
            vuln_info = self._get_vulnerability_info(cve_id)
            
            # 根据漏洞信息创建Docker环境
            container = self._create_docker_environment(vuln_info)
            
            # 保存环境信息
            environment = {
                'container': container,
                'vulnerability_info': vuln_info,
                'status': 'running'
            }
            
            self.environments[cve_id] = environment
            return environment
            
        except Exception as e:
            console.print(f"[red]环境搭建失败: {str(e)}[/red]")
            raise
            
    def _get_vulnerability_info(self, cve_id: str) -> Dict[str, Any]:
        """
        从NVD数据库获取漏洞信息
        """
        try:
            # 调用NVD API获取CVE信息
            response = requests.get(f"{self.cve_api_url}?cveId={cve_id}")
            response.raise_for_status()
            data = response.json()
            
            # 解析CVE信息
            cve_data = data['vulnerabilities'][0]['cve']
            description = cve_data['descriptions'][0]['value']
            
            # 获取受影响的产品和版本
            affected_versions = []
            for config in cve_data.get('configurations', []):
                for node in config.get('nodes', []):
                    for cpe in node.get('cpeMatch', []):
                        if 'versionEndIncluding' in cpe:
                            affected_versions.append(cpe['versionEndIncluding'])
                        elif 'versionEndExcluding' in cpe:
                            affected_versions.append(cpe['versionEndExcluding'])
            
            # 确定漏洞类型
            exploit_type = self._determine_exploit_type(description)
            
            return {
                'cve_id': cve_id,
                'description': description,
                'affected_versions': affected_versions,
                'exploit_type': exploit_type,
                'cve_data': cve_data
            }
            
        except Exception as e:
            console.print(f"[red]获取CVE信息失败: {str(e)}[/red]")
            raise
            
    def _determine_exploit_type(self, description: str) -> str:
        """
        根据漏洞描述确定漏洞类型
        """
        # 将描述转换为小写以便于匹配
        desc_lower = description.lower()
        
        # 根据关键词判断漏洞类型
        remote_keywords = ['remote', 'network', 'http', 'web', 'api']
        local_keywords = ['local', 'privilege', 'escalation', 'execute']
        
        if any(keyword in desc_lower for keyword in remote_keywords):
            return 'remote'
        elif any(keyword in desc_lower for keyword in local_keywords):
            return 'local'
        else:
            return 'unknown'
        
    def _create_docker_environment(self, vuln_info: Dict[str, Any]) -> Any:
        """
        创建Docker环境
        """
        try:
            # 创建环境目录
            env_dir = os.path.join('environments', vuln_info['cve_id'])
            os.makedirs(env_dir, exist_ok=True)
            
            # 生成Dockerfile
            dockerfile_content = self._generate_dockerfile(vuln_info)
            with open(os.path.join(env_dir, 'Dockerfile'), 'w') as f:
                f.write(dockerfile_content)
            
            # 构建Docker镜像
            console.print(f"[yellow]正在构建Docker镜像...[/yellow]")
            try:
                image, build_logs = self.client.images.build(
                    path=env_dir,
                    tag=f"vuln-env:{vuln_info['cve_id']}",
                    rm=True,  # 构建完成后删除中间层
                    pull=True,  # 总是尝试拉取最新镜像
                    timeout=600,  # 设置10分钟超时
                    forcerm=True  # 强制删除中间层
                )
                
                # 输出构建日志
                for line in build_logs:
                    if 'stream' in line:
                        console.print(f"[blue]{line['stream'].strip()}[/blue]")
                    elif 'error' in line:
                        console.print(f"[red]构建错误: {line['error']}[/red]")
                        
            except Exception as e:
                console.print(f"[red]Docker镜像构建失败: {str(e)}[/red]")
                raise
            
            # 运行容器
            console.print("[yellow]正在启动漏洞环境...[/yellow]")
            try:
                # 先检查是否存在同名容器
                existing_containers = self.client.containers.list(all=True, filters={'name': vuln_info['cve_id']})
                for container in existing_containers:
                    console.print(f"[yellow]发现同名容器，正在删除...[/yellow]")
                    container.remove(force=True)
                
                # 启动新容器
                container = self.client.containers.run(
                    image=image,
                    detach=True,
                    name=vuln_info['cve_id'],
                    ports={'8080/tcp': 8080},
                    privileged=True,
                    tty=True,  # 分配一个伪终端
                    stdin_open=True,  # 保持标准输入打开
                    volumes={
                        '/var/run/docker.sock': {
                            'bind': '/var/run/docker.sock',
                            'mode': 'rw'
                        }
                    },
                    environment={
                        'PYTHONUNBUFFERED': '1',
                        'TERM': 'xterm-256color'
                    }
                )
                
                # 等待容器启动
                time.sleep(2)
                container.reload()
                
                # 检查容器状态
                if not container.status == 'running':
                    console.print(f"[red]容器未能正常启动，状态: {container.status}[/red]")
                    # 获取容器日志
                    logs = container.logs().decode('utf-8')
                    console.print(f"[yellow]容器日志:[/yellow]\n{logs}")
                    # 获取容器详细信息
                    container_info = self.client.api.inspect_container(container.id)
                    console.print(f"[yellow]容器详细信息:[/yellow]")
                    console.print(f"状态: {container_info['State']['Status']}")
                    console.print(f"运行状态: {container_info['State']['Running']}")
                    if 'Error' in container_info['State']:
                        console.print(f"错误信息: {container_info['State']['Error']}")
                    raise Exception("容器未能正常启动")
                
                console.print(f"[green]容器已成功启动，ID: {container.id[:12]}[/green]")
                return container
                
            except Exception as e:
                console.print(f"[red]容器启动失败: {str(e)}[/red]")
                raise
            
        except Exception as e:
            console.print(f"[red]Docker环境创建失败: {str(e)}[/red]")
            raise
            
    def _generate_dockerfile(self, vuln_info: Dict[str, Any]) -> str:
        """
        根据CVE信息生成Dockerfile
        """
        # 使用更轻量级的基础镜像
        return """
FROM python:3.9-slim

# 设置工作目录
WORKDIR /app

# 安装基本工具和开发环境
RUN apt-get update && \
    DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
    build-essential \
    git \
    wget \
    sudo \
    net-tools \
    iputils-ping \
    curl \
    vim \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean

# 设置环境变量
ENV TERM=xterm-256color
ENV DEBIAN_FRONTEND=noninteractive

# 暴露端口
EXPOSE 8080

# 启动命令
CMD ["/bin/bash"]
"""
            
    def cleanup(self, cve_id: str):
        """
        清理特定CVE的环境
        """
        if cve_id in self.environments:
            environment = self.environments[cve_id]
            if environment['status'] == 'running':
                try:
                    environment['container'].stop(timeout=10)  # 设置超时时间
                    environment['container'].remove(force=True)  # 强制删除
                except Exception as e:
                    console.print(f"[yellow]清理容器时出现警告: {str(e)}[/yellow]")
            del self.environments[cve_id]
            
    def cleanup_all(self):
        """
        清理所有CVE环境
        """
        console.print("[yellow]正在清理所有Docker环境...[/yellow]")
        # 创建环境ID列表的副本，因为在清理过程中会修改environments字典
        cve_ids = list(self.environments.keys())
        for cve_id in cve_ids:
            try:
                self.cleanup(cve_id)
            except Exception as e:
                console.print(f"[red]清理 {cve_id} 环境时出错: {str(e)}[/red]")
        console.print("[green]所有环境清理完成[/green]") 
